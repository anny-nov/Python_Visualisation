# -*- coding: utf-8 -*-
"""Preedit.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11fkzREG7P0JZfJKrlDzMN4Z9Qu8I0OyO

# Описание датасета
Датасет содержит данные об аниме с сайта MAL. Состоит из 11335 строк и следующих столбцов:

Название | Описание | Формат | Шкала
--- | --- | --- | ---
mal_id |Уникальный номер на сайте MAL |int|Интервальная
aired_from |Дата выхода на экран в Японии |str, float|Относительная
aired_to |Дата окончания в Японии |str, float|Относительная
duration |Длительность одного эпизода |str| Номинальная
episodes |Количество эпизодов в тайтле |int| Относительная
genres |Перечисление всех жанров, присущих этому аниме |str| Номинальная
premiered |Сезон, в который выпущено аниме |str| Номинальная
rating |Возрастной рейтинг аниме |str| Номинальная
score |Средняя пользовательская оценка тайтла |float| Относительная
source |Первоисточник аниме |str| Номинальная
status |Закончено или не закончено аниме |str| Номинальная
studios |Данные о студии-производителе |str| Номинальная
synopsis |Краткое описание сюжета |str| Номинальная
title | Название на японском |str| Номинальная
title_english |Название на английском |str| Номинальная
type |Тип выпуска |str| Номинальная

Также датасет включает столбцы popularity и scored_by, но первый из них содержит непонятные данные, которые не удалось расшифровать, а второй - некорректные значения (только очень маленькие, либо очень большие). Поэтому от этих столбцов было решено избавиться.
"""

import pandas as pd
df = pd.read_csv("anime_data.csv", error_bad_lines=False)
df = df.drop(columns=["popularity","scored_by","rank"])
df.head()

cols = list(df.columns)
cols
df_na = {col: list(pd.isna(df[col])).count(True) for col in cols}
df_na

"""# Проблемы данных
Название | Описание | Формат | Шкала | Проблема | Решение
--- | --- | --- | --- | --- | ---
mal_id |Уникальный номер на сайте MAL |int|Интервальная|Просто значение-ключ, нет проблем| -
aired_from |Дата выхода на экран в Японии |str, float|Относительная| Кореллирует со столбцом premiered, данные в разных типах, есть пустые значения|Удалить столбец premiered как менее показательный, привести все к типу datetime, удалить строки с пустыми значениями
aired_to |Дата окончания в Японии |str, float|Относительная|Половина столбца заполнена пустыми значениями|Удалить столбец
duration |Длительность одного эпизода |str| Номинальная|В строковом формате данные неудобно использовать|Привести все к числовому типу (минутам)
episodes |Количество эпизодов в тайтле |int| Относительная| - | -
genres |Перечисление всех жанров, присущих этому аниме |str| Номинальная | - | -
premiered |Сезон, в который выпущено аниме |str| Номинальная|Больше половины столбца заполнено пустыми значениями|Удалить столбец
rating |Возрастной рейтинг аниме |str| Номинальная|Текст неудобно использовать при построении модели|Перевод в число
score |Средняя пользовательская оценка тайтла |float| Относительная|-|-
source |Первоисточник аниме |str| Номинальная |Текст неудобно использовать при построении модели|Перевод в число
status |Закончено или не закончено аниме |str| Номинальная | Почти все аниме закончены | Удалить строки с выбросами и удалить столбец
studios |Данные о студии-производителе |str| Номинальная | Лишняя информация о студии | Оставить только название
synopsis |Краткое описание сюжета |str| Номинальная|Не показательный столбец, ничего не дает|Удалить столбец
title | Название на японском |str| Номинальная|-|-
title_english |Название на английском |str| Номинальная|Достаточно много пустых строк, столбец кореллирует с японским названием | Удалить стлбец
type |Тип выпуска |str| Номинальная|Текст неудобно использовать при построении модели|Перевод в число

# Удаление столбцов
Первый шаг к предобработке данных, а также самое простое действие - удаление лишних столбцов. В ходе анализа ими оказались столбцы aired_to, premiered, synopsis и title_english. Также столбец status нуждается в удалении, но он требует дополнительной обработки перед удалением.
"""

df = df.drop(columns=["synopsis","premiered","aired_to","title_english"],axis=0)
df = df.drop(df[df.status!="Finished Airing"].index)
df = df.drop(columns=["status"],axis=0)
df.head()

"""#Столбец aired_from
Наиболее сложным и проблемным столбцом оказался столбец, содержащий дату выхода аниме на экраны. Как показала работа с описательной статистикой, столбец содержит разные типы данных, прочерки и пустые значения. Для начала решено было найти пустые значения и вручную заполнить их, так как их всего пять.
"""

import numpy as np
df.aired_from = df.aired_from.replace('', np.nan)
blank = df[df.aired_from.isnull()]
blank.head()

df.loc[3867,"aired_from"] = "2004-06-21T00:00:00+00:00"
df.loc[4656,"aired_from"] = "1927-05-01T00:00:00+00:00"
df.loc[5841,"aired_from"] = "1907-12-01T00:00:00+00:00"
df.loc[6888,"aired_from"] = "1989-01-01T00:00:00+00:00"
df.loc[7798,"aired_from"] = "2017-10-06T00:00:00+00:00"

"""Для некоторых аниме удалось выяснить лишь неполную дату (так как аниме очень старые), поэтому в качестве значений были подставлены единицы. Далее необходимо привести дату в формат datetime, потому что сейчас он расшифрован в качестве строки."""

df.dtypes

for i, row_value in df['aired_from'].iteritems():
  if type(df['aired_from'][i]) == float:
      df.loc[i,'aired_from'] = int(datetime.fromtimestamp(i).strftime('%Y'))
  if type(df['aired_from'][i]) == str:
    a = df['aired_from'][i]
    a = a[:4]
    df.loc[i,'aired_from'] = int(a)
df.head()

"""#Столбец duration
В этом столбце хранится длительность одной серии аниме в строковом формате, что совершенно неудобно для восприятия и анализа. Поэтому решено было привести все к минутам и преобразовать в числовой формат.
"""

for i, row_value in df['duration'].iteritems():
  if type(df['duration'][i]) == str:
    if "min per ep" in df['duration'][i]:
      a = df['duration'][i]
      a = a[:2]
      df.loc[i,'duration'] = int(a)
    else:
      if "hr" in df['duration'][i] and "min" in df['duration'][i]:
        a = df['duration'][i]
        h = int(a[:1])*60
        a1 = h + int(a[5:7]) 
        df.loc[i,'duration'] = int(a1)
        continue
      if not("hr" in df['duration'][i]) and "min" in df['duration'][i]:
        a = df['duration'][i].split(' ')[0]
        df.loc[i,'duration'] = int(a)
        continue
      if "sec" in df['duration'][i]:
        a = float(df['duration'][i].split(' ')[0])/60
        df.loc[i,'duration'] = float(a)
df.head()

"""#Перевод строковых данных в число
В датасете содержится три столбца, в которых количество значений ограничено: rating, source, type. Для таких столбцов удобно будет задать сетку значений, в которой каждому строковому значению будет соответствовать число, и заменить в датасете значения на выбранные числа. 
Проще всего это сделать с возрастным рейтингом: каждому значению из столбца соответствует определенный возраст, на который и можно заменить строку.

Значение  | Число
::--- | :---: 
None | 0
G - All Ages | 0
PG - Children | 7
PG-13 - Teens 13 or older | 13
R - 17+ (violence & profanity) | 17
R+ - Mild Nudity | 18
Rx - Hentai | 21
"""

for i, row_value in df['rating'].iteritems():
            if df['rating'][i] == 'None':  df.loc[i,'rating'] = 0;
            if df['rating'][i] == "G - All Ages":  df.loc[i,'rating'] = 0;
            if df['rating'][i] == "PG - Children":  df.loc[i,'rating'] = 7;
            if df['rating'][i] == "PG-13 - Teens 13 or older":  df.loc[i,'rating'] = 13;
            if df['rating'][i] == "R - 17+ (violence & profanity)":  df.loc[i,'rating'] = 17;
            if df['rating'][i] == "R+ - Mild Nudity":  df.loc[i,'rating'] = 18;
            if df['rating'][i] == "Rx - Hentai":  df.loc[i,'rating'] = 21;
df.head()

"""Столбец type также легко перевести в число, так как он содержит только шесть уникальных значений. Связи с конкретными числами у значений нет, поэтому просто проиндексируем их.

Значение  | Число
::--- | :---: 
TV | 1
OVA | 2
Movie | 3
Special | 4
ONA | 5
Music | 6
"""

for i, row_value in df['type'].iteritems():
            if df['type'][i] == 'TV':  df.loc[i,'type'] = 1;
            if df['type'][i] == "OVA":  df.loc[i,'type'] = 2;
            if df['type'][i] == "Movie":  df.loc[i,'type'] = 3;
            if df['type'][i] == "Special":  df.loc[i,'type'] = 4;
            if df['type'][i] == "ONA":  df.loc[i,'type'] = 5;
            if df['type'][i] == "Music":  df.loc[i,'type'] = 6;
df.head()

"""Столбец source является несколько более сложным для обработки, потому как (это нам известно из этапа описательной статистики) имеет довольно большое количество значений, встречающихся очень редко. Поэтому для начала нужно выделить редко встречающиеся значения и заменить их на категорию Other."""

unique_source = dict(df["source"].value_counts())
delete_list = []
for item in unique_source:
  if unique_source[item]<200:
    unique_source["Other"] = unique_source["Other"] + unique_source[item]
    delete_list.append(item)
for each in delete_list:
    del unique_source[each]
for i, row_value in df['source'].iteritems():
  if df['source'][i] in delete_list:
    df.loc[i,'source'] = "Other";
unique_source2 = dict(df["source"].value_counts())
print(unique_source2)

"""Таким образом, после обработки столбца и объединения малочисленных значений в одну категорию у нас остались следующие значения:

Значение  | Число
::--- | :---: 
Manga | 1
Original | 2
Unknown | 3
Visual novel | 4
Light novel | 5
Game | 6
Novel | 7
4-koma manga | 8
Other | 9
"""

for i, row_value in df['source'].iteritems():
            if df['source'][i] == 'Manga':  df.loc[i,'source'] = 1;
            if df['source'][i] == "Original":  df.loc[i,'source'] = 2;
            if df['source'][i] == "Unknown":  df.loc[i,'source'] = 3;
            if df['source'][i] == "Visual novel":  df.loc[i,'source'] = 4;
            if df['source'][i] == "Light novel":  df.loc[i,'source'] = 5;
            if df['source'][i] == "Game":  df.loc[i,'source'] = 6;
            if df['source'][i] == "Novel":  df.loc[i,'source'] = 7;
            if df['source'][i] == "4-koma manga":  df.loc[i,'source'] = 8;
            if df['source'][i] == "Other":  df.loc[i,'source'] = 9;
df.head()

"""#Столбец studios
Последний столбец, нуждающийся в обработке, это столбец, содержащий информацию о студии. Так как в данной работе мы больше всего сосредоточены именно на конечном продукте, а не на производителе, информация в виде структуры совершенно излишняя. Тогда необходимо оставить либо id студии, либо ее название. Но, во-первых, некоторые старые аниме не содержат информации о студии, а значит и индекса, а, во-вторых, в датасете очень много различных студий, и ориентироваться в них с помощью таблицы соответсвия Значение-Число было бы долго и неудобно. Исходя из этих причин, было решен оставить только название студии, а все неизвесные заменить на Unknown.
"""

for i, row_value in df['studios'].iteritems():
  if df['studios'][i] == "[]": df.loc[i,'studios'] = "Unknown"
  else:
    a = df['studios'][i]
    a = a.replace("'name': ","")
    a = a.replace("'mal_id': ","")
    a = a.replace("]","")
    a = a.replace("[","")
    a = a.replace("{","")
    a= a.replace("}","")
    if a != "Unknown" and "," in a: 
      a = a.split(',')[1]
      df.loc[i,'studios'] = a;
df.head()

df.to_csv('anime_data_edited.csv', index=False)

"""Таким образом, датасет прошел предобработку, данные были приведены к удобному формату, удалено лишнее и добавлена недостающая информация. Теперь, когда информация представлена в более комфортном для восприятия формате, есть возможность выдвинуть гипотезы относительно данных в дтасете. В процессе анализа данных они либо подтвердятся, либо нет.
#Гипотезы


1.   Распределение пользовательских оценок носит экспоненциальный характер
2.   Оценки старых аниме расположены дальше от среднего значения, чем новых, потому что голосовало за них меньше людей
3. Аниме, имеющие одним из жанров комедию, имеют более высокие оценки
4.  Аниме, выпущенное по манге, имеет оценки, близкие к средним значениям, так как их целевая аудитория больше
5. Аниме с рейтингом PG-13 имеет более высокие оценки, потому что подростки более лояльная аудитория.


"""