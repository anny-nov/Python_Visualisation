# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10je9Lte0wUzBafPzhMdyiLfeVHjVxi8f
"""

import pandas as pd
df = pd.read_csv("anime_data.csv")
df.head()

df.dtypes

df.shape

df.size

cols = list(df.columns)
cols
df_na = {col: list(pd.isna(df[col])).count(True) for col in cols}
df_na

df.dropna

nom_cols_data = [{name: df[col].to_list().count(name) for name in df[col].unique()}
                 for col in cols
                 if df[col].dtype == "object"]
nom_cols_data

episodes_stat = {"min": df["episodes"].min(), 
            "max": df["episodes"].max(), 
            "mean": df["episodes"].mean(),
            "median": df["episodes"].median(),
            "mode": df["episodes"].mode().to_list(),
            "var": df["episodes"].var(ddof=0),
            "std": df["episodes"].std(ddof=0),
            "range": df["episodes"].max() - df["episodes"].min(),
            "interquartile_range": df["episodes"].quantile(0.75) - df["episodes"].quantile(0.25),
            "skew": df["episodes"].skew()
            }
episodes_stat

episodes_data = {episodes: df["episodes"].to_list().count(episodes) for episodes in set(df["episodes"])}
print(episodes_data)

import matplotlib.pyplot as plt

import operator

from operator import itemgetter

episodes_data = [(episodes, df["episodes"].to_list().count(episodes)) 
                  for episodes in df["episodes"].unique() 
                  if df["episodes"].to_list().count(episodes) > 8]
episodes_data = sorted(episodes_data, key=operator.itemgetter(1))
episodes_data

episodes_amount = []
cases = []
for categ, count in episodes_data:
  if count>150:
    episodes_amount.append(categ)
    cases.append(count)

inf_df = pd.DataFrame({"episodes": episodes_amount, "cases": cases})
fig, axes = plt.subplots(nrows=1, ncols=1)
inf_df.plot.barh(ax=axes, x="episodes", y="cases", figsize=(12, 5));

"""Видно, что большинство аниме односерийные"""

type_data = {name: df["type"].to_list().count(name) for name in df["type"].unique()}
cases = []
types = []
for type1, cases_num in type_data.items():
  types.append(type1)
  cases.append(cases_num)

types_info = pd.DataFrame({"": cases},
                       index=types)
fig, axes = plt.subplots(nrows=1, ncols=1)
types_info.plot.pie(ax=axes, y="",
                 autopct="%.1f",
                 fontsize=10,
                 figsize=(12, 12));

source_data = {name: df["source"].to_list().count(name) for name in df["source"].unique()}
cases = []
sources = []
for source, cases_num in source_data.items():
  if source != "Unknown" and cases_num >150:
    sources.append(source)
    cases.append(cases_num)

source_info = pd.DataFrame({"": cases},
                       index=sources)
fig, axes = plt.subplots(nrows=1, ncols=1)
source_info.plot.pie(ax=axes, y="",
                 autopct="%.1f",
                 fontsize=10,
                 figsize=(12, 12));

score_stat = {"min": df["score"].min(), 
            "max": df["score"].max(), 
            "mean": df["score"].mean(),
            "median": df["score"].median(),
            "mode": df["score"].mode().to_list(),
            "var": df["score"].var(ddof=0),
            "std": df["score"].std(ddof=0),
            "range": df["score"].max() - df["score"].min(),
            "interquartile_range": df["score"].quantile(0.75) - df["score"].quantile(0.25),
            "skew": df["score"].skew()
            }
score_stat

import operator
score_data = {score: df["score"].to_list().count(score) for score in set(df["score"])}
score_data = sorted(score_data.items(), key=operator.itemgetter(0))
score_data = dict(score_data)
print(score_data)

import matplotlib.pyplot as plt

score_df = pd.DataFrame.from_dict(data=score_data, orient="index", columns=["score"])
score_df.head()

score_df.plot();

scored_stat = {"min": df["scored_by"].min(), 
            "max": df["scored_by"].max(), 
            "mean": df["scored_by"].mean(),
            "median": df["scored_by"].median(),
            "mode": df["scored_by"].mode().to_list(),
            "var": df["scored_by"].var(ddof=0),
            "std": df["scored_by"].std(ddof=0),
            "range": df["scored_by"].max() - df["scored_by"].min(),
            "interquartile_range": df["scored_by"].quantile(0.75) - df["scored_by"].quantile(0.25),
            "skew": df["scored_by"].skew()
            }
scored_stat

import operator
scored_data = {score: df["scored_by"].to_list().count(score) for score in set(df["scored_by"])}
scored_data = sorted(scored_data.items(), key=operator.itemgetter(0))
scored_data = dict(scored_data)
print(scored_data)

scored_df = pd.DataFrame.from_dict(data=scored_data, orient="index", columns=["scored_by"])
scored_df.head()

rating_data = {rating: df["rating"].to_list().count(rating) for rating in set(df["rating"])}
print(rating_data)
cases = []
rating = []
for rate, cases_num in rating_data.items():
  rating.append(rate)
  cases.append(cases_num)

types_info = pd.DataFrame({"": cases},
                       index=rating)
fig, axes = plt.subplots(nrows=1, ncols=1)
types_info.plot.pie(ax=axes, y="",
                 autopct="%.1f",
                 fontsize=10,
                 figsize=(12, 12));

duration_data = {duration: df["duration"].to_list().count(duration) for duration in set(df["duration"])}
duration_data
cases = []
durations = []
other_case = 0
for duration, cases_num in duration_data.items():
  if cases_num >100:
    durations.append(duration)
    cases.append(cases_num)
  else:
    other_case = other_case+1


cases_oth = []
durations_oth = []
for duration, cases_num in duration_data.items():
  if cases_num >500:
    durations_oth.append(duration)
    cases_oth.append(cases_num)
  else:
    other_case = other_case+1
durations_oth.append("Other")
cases_oth.append(other_case)

types_info1 = pd.DataFrame({"": cases},
                       index=durations)
types_info2 = pd.DataFrame({"": cases_oth},
                       index=durations_oth)
fig, axes = plt.subplots(nrows=1, ncols=2)
types_info1.plot.pie(ax=axes[0], y="",
                 autopct="%.1f",
                 fontsize=10,
                 figsize=(12, 12));
types_info2.plot.pie(ax=axes[1], y="",
                 autopct="%.1f",
                 fontsize=10,
                 figsize=(30, 30));

finished_df = df.loc[df["status"] == "Finished Airing"]
f_num = finished_df.shape[0]
f_percent = f_num / df.shape[0] * 100
print(f_num, f_percent, sep="\n")
finished_df.head()

import operator
scoref_data = {score: finished_df["score"].to_list().count(score) for score in set(finished_df["score"])}
scoref_data = sorted(scoref_data.items(), key=operator.itemgetter(0))
scoref_data = dict(scoref_data)
print(scoref_data)

score_finished_df = pd.DataFrame.from_dict(data=scoref_data, orient="index", columns=["score"])
score_finished_df.head()

score_finished_df.plot();

score_all = score_df.merge(score_finished_df, left_index=True, right_index=True)
score_all.head()

score_all.plot();

unfinished_df = df.loc[df["status"] == "Currently Airing"]
uf_num = unfinished_df.shape[0]
uf_percent = uf_num / df.shape[0] * 100
print(uf_num, uf_percent, sep="\n")
unfinished_df.head()

import operator
scoreuf_data = {score: unfinished_df["score"].to_list().count(score) for score in set(unfinished_df["score"])}
scoreuf_data = sorted(scoreuf_data.items(), key=operator.itemgetter(0))
scoreuf_data = dict(scoreuf_data)
print(scoreuf_data)

score_unfinished_df = pd.DataFrame.from_dict(data=scoreuf_data, orient="index", columns=["score"])
score_unfinished_df.head()

temp = df.genres.str.split(",")
print(temp)
import functools
import operator
unique_genres = list(functools.reduce(operator.concat, temp))
unique_genres.sort()
num = 0
for item in unique_genres:
  if "[" in item:
    item = item.replace('[','')
  if "]" in item:
    item = item.replace(']','')
  item = item.replace(' ','')
  unique_genres[num] = item
  num = num+1
print(unique_genres)

from collections import Counter
s = Counter(unique_genres)
s = dict(s)
sorted_dict = {}
sorted_keys = sorted(s, key=s.get)  # [1, 3, 2]
for w in sorted_keys:
    sorted_dict[w] = s[w]
genres_data = pd.DataFrame.from_dict(sorted_dict, orient="index")
genres_data
delete_list = []
for i in sorted_dict:
    if sorted_dict[i] < 1000:
        delete_list.append(i)
for each in delete_list:
    del sorted_dict[each]
genres_data2 = pd.DataFrame.from_dict(sorted_dict, orient="index")
genres_data2

"""ОТСОРТИРОВАТЬ"""

fig, axes = plt.subplots(nrows=1, ncols=1)
#genres_data.plot.pie(ax=axes[0], subplots=True, legend = False,
                # autopct="%.1f",
                # figsize=((10, 10)),
                # fontsize=10);
#genres_data2.plot.pie(ax=axes[1], subplots=True, legend = False,
                 #autopct="%.1f",
                 #figsize=((10, 10)),
                 #fontsize=10);
genres_data2.plot.barh(ax=axes, subplots=True, figsize=(20, 5), legend = False);

st = df.studios.str.split(",")
print(st)
studio_list = list()
num = 0
for i in st:
  if len(i)>1:
    studio_list.append(i[1])
for i in studio_list:
    i = i.replace("'name': ","")
    i = i.replace("]","")
    i = i.replace("[","")
    i = i.replace("{","")
    i = i.replace("}","")
    studio_list[num] = i
    num = num+1
print(studio_list)
import functools
import operator

from collections import Counter
c = Counter(studio_list)
c = dict(c)
sorted_dict = {}
sorted_keys = sorted(c, key=c.get)  # [1, 3, 2]
for w in sorted_keys:
    sorted_dict[w] = c[w]
delete_list = []
for i in sorted_dict:
    if sorted_dict[i] < 220:
        delete_list.append(i)
for each in delete_list:
    del sorted_dict[each]
studio_data = pd.DataFrame.from_dict(sorted_dict, orient="index")
studio_data.head()

fig, axes = plt.subplots(nrows=1, ncols=1)
studio_data.plot.pie(ax=axes,subplots=True,
                legend = False,
                 autopct="%.1f",
                 fontsize=10,
                 figsize=(30, 30));

fig, axes = plt.subplots(nrows=1, ncols=1)
studio_data.plot.barh(ax=axes, subplots=True, figsize=(20, 5), legend = False);

from datetime import datetime
import math
dates = df.aired_from
dates_list = []
num = 0
for i in dates:
  if type(i) == float:
    is_nan = math.isnan(i)
    if is_nan == False:
      i = datetime.fromtimestamp(i).strftime('%Y')
      dates_list.append(i)
  if type(i) == str and i !="-":
    i = i[:4]
    dates_list.append(i)
  num = num+1
print(dates_list)
ntens = 0
ntws = 0
nths = 0
nfs = 0
nfivs = 0
nsixs = 0
nsevs = 0
neights = 0
nnines = 0
tzeros = 0
ttens = 0
ttws = 0
for i in dates_list:
  if i >= "1910" and i< "1920": ntens = ntens+1
  if i >= "1920" and i< "1930": ntws = ntws+1
  if i >= "1930" and i< "1940": nths = nths+1
  if i >= "1940" and i< "1950": nfs = nfs+1
  if i >= "1950" and i< "1960": nfivs = nfivs+1
  if i >= "1960" and i< "1970": nsixs = nsixs+1
  if i >= "1970" and i< "1980": nsevs = nsevs+1
  if i >= "1980" and i< "1990": neights = neights+1
  if i >= "1990" and i< "2000": nnines = nnines+1
  if i >= "2000" and i< "2010": tzeros = tzeros+1
  if i >= "2010" and i< "2021": ttws = ttws+1
year_dict = dict({"1910s":ntens,"1920s":ntws,"1930s":nths,"1940s":nfs,"1950s":nfivs,"1960s":nsixs,"1970s":nsevs,"1980s":neights, "1990s":nnines, "2000s":tzeros,"2010s":ttws})
print(year_dict)

year_data = pd.DataFrame.from_dict(year_dict, orient="index")
year_data.head()

from collections import Counter
c = Counter(dates_list)
c = dict(c)
years_data = pd.DataFrame.from_dict(c, orient="index")
years_data

fig, axes = plt.subplots(nrows=1, ncols=1)
year_data.plot.barh(ax=axes, subplots=True, figsize=(20, 5), legend = False);

year_data.plot()

year_scores_data = pd.read_csv("anime_data.csv",usecols=['aired_from','score'])
year_scores_data

year_scores_data = year_scores_data.drop(year_scores_data[year_scores_data['aired_from']=='-'].index)
for i, row_value in year_scores_data['aired_from'].iteritems():
  if type(year_scores_data['aired_from'][i]) == float:
    is_nan = math.isnan(year_scores_data['aired_from'][i])
    if is_nan == False:
      year_scores_data['aired_from'][i] = int(datetime.fromtimestamp(i).strftime('%Y'))
  if type(year_scores_data['aired_from'][i]) == str and i !="-":
    a = year_scores_data['aired_from'][i]
    a = a[:4]
    year_scores_data['aired_from'][i] = int(a)
year_scores_data

year_scores_data = year_scores_data.dropna()
year_scores_data = year_scores_data.sort_index().sort_values(by='score',kind='mergesort')
year_scores_data



year_scores_data.plot(x='aired_from',y='score')